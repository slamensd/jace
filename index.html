<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Life Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            position: relative;
            touch-action: none; /* Prevent scrolling and zooming on touch */
        }
        .cell {
            width: 20px;
            height: 20px;
            background-color: red;
            border-radius: 50%;
            position: absolute;
        }
    </style>
</head>
<body>

<script>
    let cells = [];
    let cellIndex = 0;

    function createCell(x, y) {
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.style.left = `${x - 10}px`;
        cell.style.top = `${y - 10}px`;
        cell.dataset.index = cellIndex++;
        cells.push({ element: cell, vx: Math.random() * 4 - 2, vy: Math.random() * 4 - 2 });
        document.body.appendChild(cell);
    }

    function multiplyCells() {
        let newCells = [];
        for (const { element: cell } of cells) {
            const rect = cell.getBoundingClientRect();
            const offsets = [
                {x: -30, y: -30},
                {x: 30, y: -30},
                {x: -30, y: 30},
                {x: 30, y: 30},
            ];
            for (const offset of offsets) {
                const newX = rect.left + window.scrollX + offset.x;
                const newY = rect.top + window.scrollY + offset.y;
                newCells.push({x: newX, y: newY});
            }
        }
        newCells.forEach(pos => createCell(pos.x, pos.y));
    }

    function updateCells() {
        for (let i = 0; i < cells.length; i++) {
            const cell = cells[i];
            const rect = cell.element.getBoundingClientRect();

            // Update position
            let newX = rect.left + cell.vx;
            let newY = rect.top + cell.vy;

            // Bounce off walls
            if (newX <= 0 || newX + rect.width >= window.innerWidth) {
                cell.vx *= -1;
            }
            if (newY <= 0 || newY + rect.height >= window.innerHeight) {
                cell.vy *= -1;
            }

            cell.element.style.left = `${newX}px`;
            cell.element.style.top = `${newY}px`;

            // Handle collisions
            for (let j = i + 1; j < cells.length; j++) {
                const otherCell = cells[j];
                const otherRect = otherCell.element.getBoundingClientRect();

                const dx = rect.left - otherRect.left;
                const dy = rect.top - otherRect.top;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < rect.width) {
                    // Simple collision response by reversing velocities
                    cell.vx *= -1;
                    cell.vy *= -1;
                    otherCell.vx *= -1;
                    otherCell.vy *= -1;
                }
            }
        }

        requestAnimationFrame(updateCells);
    }

    window.addEventListener('click', function (e) {
        if (cells.length === 0) {
            createCell(e.clientX, e.clientY);
            requestAnimationFrame(updateCells);
        } else {
            multiplyCells();
        }
    });

    window.addEventListener('touchstart', function (e) {
        e.preventDefault();
        const touch = e.touches[0];
        if (cells.length === 0) {
            createCell(touch.clientX, touch.clientY);
            requestAnimationFrame(updateCells);
        } else {
            multiplyCells();
        }
    });
</script>

</body>
</html>
